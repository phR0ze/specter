// JPEG's are constructed using `Markers`. Markers are a binary formatted value used to mark a segment
// of the file for a specific purpose e.g. start of the image data, end of the image data, app specific
// segments etc...
use nom::{bytes::streaming as nom_bytes, error::Error as NomError, number::streaming as nom_nums};
use std::io::{self, prelude::*};

use crate::{
    errors::{CastError, JpegError, JpegErrorKind, MetaError},
    Exif, Jfif, Kind, Meta,
};

// JPEG Markers
pub(crate) mod marker {
    pub(crate) const PREFIX: u8 = 0xFF; // JPEG marker prefix
    pub(crate) const HEADER: [u8; 2] = [0xFF, 0xD8]; // Start of any JPEG file
    pub(crate) const SOS: [u8; 2] = [0xFF, 0xDA]; // Start of scan i.e. start of image data
    pub(crate) const EOI: [u8; 2] = [0xFF, 0xD9]; // End of image data
    pub(crate) const APP0: [u8; 2] = [0xFF, 0xE0]; // JFIF marker segment
    pub(crate) const APP1: [u8; 2] = [0xFF, 0xE1]; // Exif marker segment
    pub(crate) const APP2: [u8; 2] = [0xFF, 0xE2]; // CIFF Canon Camera Image File Format
    pub(crate) const APP8: [u8; 2] = [0xFF, 0xE8]; // SPIFF Still Picture Interchange File Format
}

// JPEG segments are defined by an identifier, their length and the data they contain
#[derive(Debug, PartialEq)]
struct Segment {
    marker: [u8; 2], // JPEG segment identifier
    length: u16,     // JPEG segment length
    data: Vec<u8>,   // JPEG segment data
}
impl Segment {
    fn new(marker: [u8; 2], length: u16, data: Vec<u8>) -> Self {
        Self {
            marker,
            length,
            data,
        }
    }
}

/// Parse all meta data from the given JPEG source.
pub fn parse(mut reader: impl io::BufRead) -> Result<(Option<Jfif>, Option<Exif>), JpegError> {
    let mut jfif: Option<Jfif> = None;
    let mut exif: Option<Exif> = None;

    // Check the header to determine the media type
    parse_header(&mut reader)?;

    let chunk_len = 10;

    // Loop over the source reading chunks of data and parse it into segments.
    // * Progressively load more data until all segments are parsed, but bail before
    //   reading the actual image data to avoid the unnecessary overhead.
    // * Break out into a multi-threaded approach later for performance, maybe?
    //   Highest performance option is to use a single thread to read data in chunks in
    //   a loop until all segments are parsed and image data is detected then abort.
    //   Meanwhile a worker thread is spawned to parse the segmments in parallel.
    let mut eof = false;
    let mut more_data_needed = false;
    let mut unused: Vec<u8> = Vec::with_capacity(4096); // rust std use 8k for most things
    loop {
        // Defensively discard unrecognized bytes up to next marker in an attempt to recover
        // from a corrupt JPEG source. Note: read_until will also discard the target value.
        // reader.read_until(JPEG_MARKER_PREFIX, &mut Vec::new());

        // Read the next chunk of data and store it in the buffer
        let mut buf: Vec<u8> = Vec::with_capacity(chunk_len);
        match reader.by_ref().take(chunk_len as u64).read_to_end(&mut buf) {
            Ok(0) => eof = true,
            Err(e) => return Err(JpegError::read_failed().with_io_source(e)),
            _ => (),
        }

        // Parse segements switching on APP segment header
        match parse_segment(&buf) {
            Ok((remain, segment)) => match segment.marker {
                marker::APP0 => {
                    jfif = Some(Jfif::parse(&segment.data)?);
                }
                marker::APP1 => {
                    exif = Some(Exif::parse(&segment.data)?);
                }
                // check for last segment?
                _ => {
                    return Err(JpegError::segment_marker_unknown(remain));
                }
            },
            Err(JpegError {
                kind: JpegErrorKind::NotEnoughData,
                ..
            }) => {
                more_data_needed = true;
            }
            Err(e) => {
                return Err(JpegError::failed().wrap(e));
            }
        }

        // Broken JPEG source, no more data to read
        if more_data_needed && eof {
            return Err(JpegError::not_enough_data());
        }
        // buf.clear();
        break;
    }

    Ok((jfif, exif))
}

// Determine if the given header is from a jpeg source
pub fn is_jpeg(header: &[u8]) -> bool {
    header.starts_with(&marker::HEADER)
}
fn parse_header(mut reader: impl io::BufRead) -> Result<bool, JpegError> {
    let mut header = [0u8; 2];
    reader
        .by_ref()
        .read_exact(&mut header)
        .map_err(|x| JpegError::read_failed().with_io_source(x))?;
    match is_jpeg(&header) {
        true => Ok(true),
        false => {
            return Err(JpegError::header_invalid());
        }
    }
}

/// Parse out a segment. A segment has the following structure left to right:
/// * (1 byte)  Marker prefix e.g `0xFF`
/// * (1 byte)  Marker Number e.g. `0xE0`
/// * (2 bytes) Data size, including 2 size bytes, in Big Endian e.g. e.g 0x00 0x10 = 14 bytes
fn parse_segment(input: &[u8]) -> Result<(&[u8], Segment), JpegError> {
    let (remain, marker) = parse_marker(input)?;

    // Match marker and parse the corresponding segment type
    match marker {
        marker::APP0 | marker::APP1 => {
            let (remain, length) = parse_length(remain)?;
            let (remain, data) = parse_data(remain, length)?;
            Ok((remain, Segment::new(marker, length, data)))
        }
        _ => Err(JpegError::segment_marker_unknown(&marker)),
    }
}

/// Parse out a JPEG marker which is a 2 byte value consisting of:
/// * (1 byte) magic hex value `0xFF`
/// * (1 byte) number e.g. `0xE0`
fn parse_marker(input: &[u8]) -> Result<(&[u8], [u8; 2]), JpegError> {
    nom::sequence::preceded(
        nom_bytes::tag::<[u8; 1], &[u8], NomError<&[u8]>>([marker::PREFIX]),
        nom_nums::u8,
    )(input)
    .map(|(remain, num)| (remain, [marker::PREFIX, num]))
    .map_err(|e| JpegError::segment_marker_invalid().with_nom_source(e))
}

/// Parse out a JPEG segment length 2 byte in Big Endian format that includes the 2 size bytes.
/// Thus a length of `0x00 0x10` would be length 14 not 16.
fn parse_length(input: &[u8]) -> Result<(&[u8], u16), JpegError> {
    let (remain, length) = nom_nums::be_u16(input)
        .map_err(|x| JpegError::segment_length_invalid().with_nom_source(x))?;
    Ok((remain, length - 2))
}

/// Parse out a JPEG segment data.
fn parse_data(input: &[u8], length: u16) -> Result<(&[u8], Vec<u8>), JpegError> {
    let (remain, data) = nom::multi::count(nom_nums::u8, length as usize)(input)
        .map_err(|x| JpegError::segment_data_invalid().with_nom_source(x))?;

    // Convert the data to a vector
    let mut vec = Vec::with_capacity(length as usize);
    vec.extend_from_slice(&data);

    Ok((remain, vec))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_provide_more_data() {
        let mut data = io::Cursor::new([0xFF, 0xD8, 0x00, 0x00, 0xFF, 0xE1]);
        //let err = Jpeg::parse(&mut data).unwrap_err();
        //assert_eq!(err.to_string(), "jpeg segment invalid");
    }

    #[test]
    fn test_parse_header_invalid() {
        let mut header = io::Cursor::new([0xFF, 0x00]);
        assert_eq!(
            parse_header(&mut header).unwrap_err().to_string(),
            JpegError::header_invalid().to_string()
        );
    }

    #[test]
    fn test_parse_header_valid() {
        let mut header = io::Cursor::new(marker::HEADER);
        assert!(parse_header(&mut header).is_ok());
    }

    #[test]
    fn test_is_jpeg() {
        assert_eq!(is_jpeg(&marker::HEADER), true);
        assert_eq!(is_jpeg(&[0xFF, 0xF0]), false);
    }

    #[test]
    fn test_parse_segment_ask_for_more_data() {
        let err = parse_segment(&[]).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        let err1 = err.as_ref().source().unwrap();
        assert_eq!(err1.to_string(), "nom::Parsing requires 1 bytes/chars");
    }

    #[test]
    fn test_parse_segment_exif_success() {
        // skip the jpeg header and jfif segment
        let (_, segment) = parse_segment(&JPEG_DATA_1[20..]).unwrap();
        assert_eq!(segment.marker, marker::APP1);
        assert_eq!(segment.length, 860);
        assert_eq!(segment.data.len(), 860);
    }

    #[test]
    fn test_parse_segment_jfif_success() {
        let (remain, segment) = parse_segment(&JFIF_DATA_1).unwrap();
        assert_eq!(segment.marker, marker::APP0);
        assert_eq!(segment.data, &JFIF_DATA_1[4..]);
        assert_eq!(remain, &[]);
        assert_eq!(
            std::str::from_utf8(&segment.data).unwrap(),
            "JFIF\0\u{1}\u{2}\u{1}\0H\0H\0\0"
        );
    }

    #[test]
    fn test_parse_segment_marker_unknown() {
        let err = parse_segment(&[0xff, 0xe9]).unwrap_err();
        assert_eq!(
            err.to_string(),
            JpegError::segment_marker_unknown(&[0xff, 0xe9]).to_string()
        );
    }

    #[test]
    fn test_parse_data_ask_for_more_data() {
        let err = parse_data(&[], 20).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        let err1 = err.as_ref().source().unwrap();
        assert_eq!(err1.to_string(), "nom::Parsing requires 1 bytes/chars");
    }

    #[test]
    fn test_parse_data_parser() {
        let (remain, data) = parse_data(&JFIF_DATA_1[4..], 14).unwrap();
        assert_eq!(remain, &[]);
        assert_eq!(data, &JFIF_DATA_1[4..]);
    }

    #[test]
    fn test_parse_length_ask_for_more_data() {
        let err = parse_length(&[]).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        let err1 = err.as_ref().source().unwrap();
        assert_eq!(err1.to_string(), "nom::Parsing requires 2 bytes/chars");
    }

    #[test]
    fn test_parse_length_success() {
        {
            let (remain, length) = parse_length(&[0x00, 0x03, 0x02]).unwrap();
            assert_eq!(remain, &[0x02]);
            assert_eq!(length, 1);
        }
        {
            let (remain, length) = parse_length(&JFIF_DATA_1[2..]).unwrap();
            assert_eq!(remain, &JFIF_DATA_1[4..]);
            assert_eq!(length, 14);
        }
    }

    #[test]
    fn test_parse_marker_ask_for_more_data() {
        let err = parse_marker(&[0xFF]).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        let err1 = err.as_ref().source().unwrap();
        assert_eq!(err1.to_string(), "nom::Parsing requires 1 bytes/chars");
    }

    #[test]
    fn test_parse_marker_success() {
        let (remain, marker) = parse_marker(&JFIF_DATA_1).unwrap();
        assert_eq!(remain, &JFIF_DATA_1[2..]);
        assert_eq!(marker, [0xFF, 0xE0]);
    }

    #[test]
    fn test_parse_marker_fail() {
        let result = parse_marker(&JFIF_DATA_1[2..]);
        assert!(result.is_err());
        let err = result.unwrap_err();

        assert_eq!(
            err.to_string(),
            JpegError::segment_marker_invalid().to_string()
        );
        assert_eq!(
            err.as_ref().source().unwrap().to_string(),
            "nom::Parsing Error: Error { input: [0, 16, 74, 70, 73, 70, 0, 1, 2, 1, 0, 72, 0, 72, 0, 0], code: Tag }"
        );
    }

    const JFIF_DATA_1: [u8; 18] = [
        0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x02, 0x01, 0x00, 0x48, 0x00,
        0x48, 0x00, 0x00,
    ];

    const JPEG_DATA_1: [u8; 1260] = [
        0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00,
        0x48, 0x00, 0x48, 0x00, 0x00, 0xff, 0xe1, 0x03, 0x5e, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00,
        0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x01, 0x0e, 0x00, 0x02, 0x00,
        0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x56, 0x01, 0x1a, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x62, 0x01, 0x1b, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x6a, 0x01, 0x28, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x01, 0x32,
        0x00, 0x02, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x72, 0x87, 0x69, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00, 0xb0, 0x54, 0x65, 0x73, 0x74,
        0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x00, 0x46, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x32, 0x30, 0x31, 0x36, 0x3a, 0x30,
        0x35, 0x3a, 0x30, 0x34, 0x20, 0x30, 0x33, 0x3a, 0x30, 0x32, 0x3a, 0x30, 0x31, 0x00, 0x00,
        0x03, 0x90, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x04, 0x30, 0x32, 0x33, 0x30, 0xa0, 0x02,
        0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0f, 0x00, 0x00, 0xa0, 0x03, 0x00, 0x03, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x01,
        0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xce, 0x02, 0x02, 0x00, 0x04, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x88, 0x00, 0x00, 0x00, 0x00, 0xff, 0xd8, 0xff, 0xe0,
        0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
        0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07,
        0x07, 0x09, 0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13,
        0x0f, 0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d, 0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20,
        0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29, 0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f,
        0x27, 0x39, 0x3d, 0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34, 0x32, 0xff, 0xdb, 0x00, 0x43, 0x01,
        0x09, 0x09, 0x09, 0x0c, 0x0b, 0x0c, 0x18, 0x0d, 0x0d, 0x18, 0x32, 0x21, 0x1c, 0x21, 0x32,
        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
        0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
        0x32, 0x32, 0x32, 0x32, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x03, 0x00, 0x07, 0x03, 0x01,
        0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01,
        0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5,
        0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,
        0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13,
        0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1,
        0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19,
        0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43,
        0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
        0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
        0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
        0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
        0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff,
        0xc4, 0x00, 0x1f, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
        0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04,
        0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05,
        0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14,
        0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a,
        0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a,
        0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53,
        0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
        0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
        0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2,
        0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8,
        0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5,
        0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03,
        0x11, 0x00, 0x3f, 0x00, 0xf4, 0x5d, 0x1e, 0x15, 0xb9, 0x96, 0xd2, 0x09, 0x9a, 0x57, 0x89,
        0x0c, 0x85, 0x53, 0xcd, 0x6c, 0x77, 0xf7, 0xe6, 0x8a, 0x28, 0xa0, 0x0f, 0xff, 0xd9, 0xff,
        0xdb, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
        0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07, 0x07, 0x06, 0x08,
        0x0c, 0x0a, 0x0c, 0x0c, 0x0b, 0x0a, 0x0b, 0x0b, 0x0d, 0x0e, 0x12, 0x10, 0x0d, 0x0e, 0x11,
        0x0e, 0x0b, 0x0b, 0x10, 0x16, 0x10, 0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f, 0x17,
        0x18, 0x16, 0x14, 0x18, 0x12, 0x14, 0x15, 0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04,
        0x04, 0x05, 0x04, 0x05, 0x09, 0x05, 0x05, 0x09, 0x14, 0x0d, 0x0b, 0x0d, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
        0x14, 0x14, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x07, 0x00, 0x0f, 0x03, 0x01, 0x11, 0x00,
        0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00, 0x15, 0x00, 0x01, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x08, 0xff,
        0xc4, 0x00, 0x1f, 0x10, 0x00, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07, 0x12, 0x13, 0x14,
        0x15, 0x16, 0xff, 0xc4, 0x00, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x11, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xff, 0xdd, 0x00, 0x04, 0x00, 0x20, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02,
        0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xaa, 0x70, 0x7a, 0xcd, 0xe5, 0x83, 0xcc, 0xd9, 0xb3,
        0x1a, 0xa6, 0xb0, 0xb7, 0x9f, 0x61, 0x93, 0x4d, 0x7a, 0xb1, 0x2e, 0xe5, 0xfb, 0x91, 0xca,
        0xb5, 0x5e, 0xb2, 0x72, 0x39, 0x47, 0x43, 0xba, 0x50, 0x0e, 0x40, 0xa1, 0x20, 0xb4, 0x31,
        0xe1, 0xf4, 0xbe, 0x36, 0x5c, 0x54, 0x12, 0x39, 0x91, 0x41, 0x56, 0x3f, 0x85, 0x6d, 0x39,
        0xfb, 0xb3, 0x0c, 0xba, 0xb5, 0x97, 0xf2, 0xb0, 0xca, 0xaf, 0xd5, 0x94, 0xba, 0xb6, 0xe6,
        0xca, 0x77, 0xce, 0xe3, 0xb6, 0x7c, 0xd7, 0x38, 0xea, 0xfb, 0xca, 0x2e, 0xf7, 0x10, 0x91,
        0xd0, 0x03, 0x68, 0xdb, 0x8f, 0xc3, 0xc0, 0x80, 0xda, 0xb8, 0xc2, 0x47, 0x0f, 0xff, 0xd9,
    ];
}
