// JPEG's are constructed using `Markers`. Markers are a binary formatted value used to mark a segment
// of the file for a specific purpose e.g. start of the image data, end of the image data, app specific
// segments etc...
use nom::{bytes::streaming as nom_bytes, error::Error as NomError, number::streaming as nom_nums};
use std::io::{self, prelude::*};

use crate::{
    errors::{CastError, JpegError, JpegErrorKind, MetaError},
    exif::{self, Exif},
    jfif::{self, Jfif},
    Kind, Meta,
};

// JPEG Markers
pub(crate) mod marker {
    pub(crate) const PREFIX: u8 = 0xFF; // JPEG marker prefix
    pub(crate) const HEADER: [u8; 2] = [0xFF, 0xD8]; // Start of any JPEG file
    pub(crate) const SOF: [u8; 2] = [0xFF, 0xC0]; // Start of frame
    pub(crate) const DHT: [u8; 2] = [0xFF, 0xC4]; // Define Huffman Table
    pub(crate) const EOI: [u8; 2] = [0xFF, 0xD9]; // End of image data
    pub(crate) const SOS: [u8; 2] = [0xFF, 0xDA]; // Start of scan i.e. start of image data
    pub(crate) const DQT: [u8; 2] = [0xFF, 0xDB]; // Define Quantinization Table
    pub(crate) const DRI: [u8; 2] = [0xFF, 0xDD]; // Define restart interval
    pub(crate) const APP0: [u8; 2] = [0xFF, 0xE0]; // JFIF marker segment
    pub(crate) const APP1: [u8; 2] = [0xFF, 0xE1]; // Exif marker segment
    pub(crate) const APP2: [u8; 2] = [0xFF, 0xE2]; // CIFF Canon Camera Image File Format
    pub(crate) const APP8: [u8; 2] = [0xFF, 0xE8]; // SPIFF Still Picture Interchange File Format
}

// JPEG segments are defined by an identifier, their length and the data they contain
#[derive(Debug, PartialEq)]
struct Segment {
    marker: [u8; 2],       // JPEG segment identifier
    length: u16,           // JPEG segment length
    data: Option<Vec<u8>>, // JPEG segment data
}
impl Segment {
    fn new(marker: [u8; 2], length: u16, data: Option<Vec<u8>>) -> Self {
        Self {
            marker,
            length,
            data,
        }
    }
}

/// Parse all meta data from the given JPEG source.
pub fn parse(mut reader: impl io::BufRead) -> Result<(Option<Jfif>, Option<Exif>), JpegError> {
    let mut jfif: Option<Jfif> = None;
    let mut exif: Option<Exif> = None;

    // Check the header to determine the media type
    parse_header(&mut reader)?;

    let chunk_len = 10;

    // Loop over the source reading chunks of data and parse it into segments.
    // * Progressively load more data until all segments are parsed, but bail before
    //   reading the actual image data to avoid the unnecessary overhead.
    // * Break out into a multi-threaded approach later for performance, maybe?
    //   Highest performance option is to use a single thread to read data in chunks in
    //   a loop until all segments are parsed and image data is detected then abort.
    //   Meanwhile a worker thread is spawned to parse the segmments in parallel.
    let mut end_of_meta_data = false;
    let mut get_more_data = false;
    let mut buffer: Vec<u8> = Vec::with_capacity(4096); // rust std use 8k for most things
    let mut i = 0; // unacked start
    let mut j = 0; // unacked length
    loop {
        // Defensively discard unrecognized bytes up to next marker in an attempt to recover
        // from a corrupt JPEG source. Note: read_until will also discard the target value.
        // reader.read_until(JPEG_MARKER_PREFIX, &mut Vec::new());

        // Read the next chunk of data and store it in the buffer
        let mut buf: Vec<u8> = Vec::with_capacity(chunk_len);
        match reader.by_ref().take(chunk_len as u64).read_to_end(&mut buf) {
            Ok(0) => end_of_meta_data = true,
            Err(e) => return Err(JpegError::read_failed().with_io_source(e)),
            _ => (),
        }
        j += buf.len();
        buffer.extend_from_slice(&buf);
        get_more_data = false;

        // Loop parsing all segements switching on APP segment header
        loop {
            match parse_segment(&buffer[i..i + j]) {
                Ok((remain, segment)) => match segment.marker {
                    marker::APP0 => {
                        jfif = Some(jfif::parse(&segment.data.unwrap())?);
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::APP1 => {
                        exif = Some(exif::parse(&segment.data.unwrap())?);
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::DQT | marker::SOF | marker::DHT | marker::DRI => {
                        // Not sure what these are for yet
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::SOS => {
                        // last segment before image data so break out
                        end_of_meta_data = true;
                        break;
                    }
                    _ => {
                        return Err(JpegError::segment_marker_unknown(remain));
                    }
                },
                Err(JpegError {
                    kind: JpegErrorKind::NotEnoughData,
                    ..
                }) => {
                    get_more_data = true;
                    break;
                }
                Err(e) => {
                    return Err(JpegError::failed().wrap(e));
                }
            }
        }

        // End of metadata i.e. no more data in file or hit SOS
        if end_of_meta_data {
            if get_more_data {
                // If more data is needed must be a broken JPEG source
                return Err(JpegError::not_enough_data());
            }
            break;
        }
    }

    Ok((jfif, exif))
}

// Determine if the given header is from a jpeg source
pub fn is_jpeg(header: &[u8]) -> bool {
    header.starts_with(&marker::HEADER)
}

// Parsee the JPEG header
fn parse_header(mut reader: impl io::BufRead) -> Result<bool, JpegError> {
    let mut header = [0u8; 2];
    reader
        .by_ref()
        .read_exact(&mut header)
        .map_err(|x| JpegError::read_failed().with_io_source(x))?;
    match is_jpeg(&header) {
        true => Ok(true),
        false => {
            return Err(JpegError::header_invalid());
        }
    }
}

/// Parse out a segment. A segment has the following structure left to right:
/// * (1 byte)  Marker prefix e.g `0xFF`
/// * (1 byte)  Marker Number e.g. `0xE0`
/// * (2 bytes) Data size, including 2 size bytes, in Big Endian e.g. e.g 0x00 0x10 = 14 bytes
fn parse_segment(input: &[u8]) -> Result<(&[u8], Segment), JpegError> {
    let (remain, marker) = parse_segment_marker(input)?;

    // Match marker and parse the corresponding segment type
    match marker {
        // Parse segments with data
        marker::APP0 | marker::APP1 | marker::DQT | marker::SOF | marker::DHT | marker::DRI => {
            let (remain, length) = parse_segment_length(remain)?;
            let (remain, data) = parse_segment_data(remain, length)?;
            Ok((remain, Segment::new(marker, length, Some(data))))
        }

        // Parse segments with no data.
        // SOS actually has data but we don't care about the image data for metadata parsing
        marker::SOS => Ok((remain, Segment::new(marker, 0, None))),

        // Unknown segment
        _ => Err(JpegError::segment_marker_unknown(&marker)),
    }
}

// Parse out a JPEG segment marker which is a 2 byte value consisting of:
// * (1 byte) magic hex value `0xFF`
// * (1 byte) number e.g. `0xE0`
fn parse_segment_marker(input: &[u8]) -> Result<(&[u8], [u8; 2]), JpegError> {
    nom::sequence::preceded(
        nom_bytes::tag::<[u8; 1], &[u8], NomError<&[u8]>>([marker::PREFIX]),
        nom_nums::u8,
    )(input)
    .map(|(remain, num)| (remain, [marker::PREFIX, num]))
    .map_err(|e| JpegError::segment_marker_invalid().with_nom_source(e))
}

// Parse out a JPEG segment length 2 byte in Big Endian format that includes the 2 size bytes.
// Thus a length of `0x00 0x10` would be length 14 not 16.
fn parse_segment_length(input: &[u8]) -> Result<(&[u8], u16), JpegError> {
    nom_nums::be_u16(input)
        .map(|(remain, val)| (remain, val - 2))
        .map_err(|x| JpegError::segment_length_invalid().with_nom_source(x))
}

// Parse out the segment data
fn parse_segment_data(input: &[u8], length: u16) -> Result<(&[u8], Vec<u8>), JpegError> {
    nom::multi::count(nom_nums::u8, length as usize)(input)
        .map_err(|x| JpegError::segment_data_invalid().with_nom_source(x))
}

#[cfg(test)]
pub(crate) const JPEG_TEST_DATA: [u8; 1260] = [
    /* 000-001 */ 0xff, 0xd8, // JPEG header
    /* 002-003 */ 0xff, 0xe0, // JFIF: marker
    /* 004-005 */ 0x00, 0x10, // JFIF: size
    /* 006-010 */ 0x4a, 0x46, 0x49, 0x46, 0x00, // JFIF: signature
    /* 011-019 */ 0x01, 0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, // JFIF: data
    /* 020-021 */ 0xff, 0xe1, // Exif: marker
    /* 022-023 */ 0x03, 0x5e, // Exif: size 862
    /* 024-029 */ 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, // Exif: signature
    //
    // TIFF header
    /* 030-031 */ 0x4d, 0x4d, // byte alignment
    /* 032-033 */ 0x00, 0x2a, // identifier
    //
    // IFD 0
    /* 034-037 */ 0x00, 0x00, 0x00, 0x08, // IFD 0: offset
    /* 038-039 */ 0x00, 0x06, // IFD 0: tag count
    //
    /* 040-041 */ 0x01, 0x0e, // Tag 0: tag Image description
    /* 042-043 */ 0x00, 0x02, // Tag 0: format ASCII
    /* 044-047 */ 0x00, 0x00, 0x00, 0x0b, // Tag 0: components
    /* 048-051 */ 0x00, 0x00, 0x00, 0x56, // Tag 0: offset (86)
    //
    /* 052-053 */ 0x01, 0x1a, // Tag 1: tag (258) - XResolution
    /* 054-055 */ 0x00, 0x05, // Tag 1: format Unsigned Rational
    /* 056-059 */ 0x00, 0x00, 0x00, 0x01, // Tag 1: components
    /* 060-063 */ 0x00, 0x00, 0x00, 0x62, // Tag 1: offset (98)
    //
    /* 064-065 */ 0x01, 0x1b, // Tag 2: YResolution
    /* 066-067 */ 0x00, 0x05, // Tag 2: format
    /* 068-071 */ 0x00, 0x00, 0x00, 0x01, // Tag 2: components
    /* 072-075 */ 0x00, 0x00, 0x00, 0x6a, // Tag 2: offset (106)
    //
    /* 076-077 */ 0x01, 0x28, // Tag 3: Resolution Unit
    /* 078-079 */ 0x00, 0x03, // Tag 3: Unsigned short
    /* 080-083 */ 0x00, 0x00, 0x00, 0x01, // Tag 3: components
    /* 084-087 */ 0x00, 0x02, 0x00, 0x00, // Tag 3: data (512)
    //
    /* 088-089 */ 0x01, 0x32, // Tag 4: Date Time
    /* 090-091 */ 0x00, 0x02, // Tag 4: ASCII
    /* 092-095 */ 0x00, 0x00, 0x00, 0x14, // Tag 4: components (20)
    /* 096-099 */ 0x00, 0x00, 0x00, 0x72, // Tag 4: offset (114)
    //
    /* 100-101 */ 0x87, 0x69, // Tag 5: ExifOffset
    /* 102-103 */ 0x00, 0x04, // Tag 5: Unsigned Long
    /* 104-107 */ 0x00, 0x00, 0x00, 0x01, // Tag 5: components
    /* 108-111 */ 0x00, 0x00, 0x00, 0x86, // Tag 5: data (134)
    //
    // IFD 1
    /* 112-115 */ 0x00, 0x00, 0x00, 0xb0, // IFD 1: offset (176)
    /* 116-127 */ 0x54, 0x65, // IFD 1: tag count
    /* 116-127 */ 0x73, 0x74, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x00, 0x46,
    /* 128-139 */ 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x48,
    /* 000-151 */ 0x00, 0x00, 0x00, 0x01, 0x32, 0x30, 0x31, 0x36, 0x3a, 0x30, 0x35, 0x3a,
    /* 000-163 */ 0x30, 0x34, 0x20, 0x30, 0x33, 0x3a, 0x30, 0x32, 0x3a, 0x30, 0x31, 0x00,
    /* 000-175 */ 0x00, 0x03, 0x90, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x04, 0x30, 0x32,
    /* 000-187 */ 0x33, 0x30, 0xa0, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0f,
    /* 000-199 */ 0x00, 0x00, 0xa0, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07,
    /* 000-211 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x01, 0x00, 0x04,
    /* 000-223 */ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xce, 0x02, 0x02, 0x00, 0x04,
    /* 000-235 */ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x88, 0x00, 0x00, 0x00, 0x00,
    /* 000-247 */ 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01,
    /* 000-259 */ 0x01, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43,
    0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0a, 0x0c,
    0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13, 0x0f, 0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d,
    0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29,
    0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d, 0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34,
    0x32, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x09, 0x09, 0x09, 0x0c, 0x0b, 0x0c, 0x18, 0x0d, 0x0d, 0x18,
    0x32, 0x21, 0x1c, 0x21, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00, 0x03, 0x00, 0x07, 0x03,
    0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01,
    0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x10, 0x00,
    0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7d, 0x01,
    0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22,
    0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24,
    0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29,
    0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
    0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
    0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
    0xfa, 0xff, 0xc4, 0x00, 0x1f, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
    0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07,
    0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31,
    0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1,
    0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1,
    0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39,
    0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
    0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
    0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5,
    0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3,
    0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
    0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00,
    0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xf4, 0x5d, 0x1e, 0x15, 0xb9, 0x96, 0xd2, 0x09, 0x9a,
    0x57, 0x89, 0x0c, 0x85, 0x53, 0xcd, 0x6c, 0x77, 0xf7, 0xe6, 0x8a, 0x28, 0xa0, 0x0f, 0xff, 0xd9,
    0xff, 0xdb, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
    0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07, 0x07, 0x06, 0x08, 0x0c,
    0x0a, 0x0c, 0x0c, 0x0b, 0x0a, 0x0b, 0x0b, 0x0d, 0x0e, 0x12, 0x10, 0x0d, 0x0e, 0x11, 0x0e, 0x0b,
    0x0b, 0x10, 0x16, 0x10, 0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f, 0x17, 0x18, 0x16, 0x14,
    0x18, 0x12, 0x14, 0x15, 0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05,
    0x09, 0x05, 0x05, 0x09, 0x14, 0x0d, 0x0b, 0x0d, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00,
    0x07, 0x00, 0x0f, 0x03, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00,
    0x15, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x08, 0xff, 0xc4, 0x00, 0x1f, 0x10, 0x00, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x12, 0x13, 0x14, 0x15, 0x16, 0xff, 0xc4, 0x00, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x11,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xdd, 0x00, 0x04, 0x00, 0x20, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11,
    0x03, 0x11, 0x00, 0x3f, 0x00, 0xaa, 0x70, 0x7a, 0xcd, 0xe5, 0x83, 0xcc, 0xd9, 0xb3, 0x1a, 0xa6,
    0xb0, 0xb7, 0x9f, 0x61, 0x93, 0x4d, 0x7a, 0xb1, 0x2e, 0xe5, 0xfb, 0x91, 0xca, 0xb5, 0x5e, 0xb2,
    0x72, 0x39, 0x47, 0x43, 0xba, 0x50, 0x0e, 0x40, 0xa1, 0x20, 0xb4, 0x31, 0xe1, 0xf4, 0xbe, 0x36,
    0x5c, 0x54, 0x12, 0x39, 0x91, 0x41, 0x56, 0x3f, 0x85, 0x6d, 0x39, 0xfb, 0xb3, 0x0c, 0xba, 0xb5,
    0x97, 0xf2, 0xb0, 0xca, 0xaf, 0xd5, 0x94, 0xba, 0xb6, 0xe6, 0xca, 0x77, 0xce, 0xe3, 0xb6, 0x7c,
    0xd7, 0x38, 0xea, 0xfb, 0xca, 0x2e, 0xf7, 0x10, 0x91, 0xd0, 0x03, 0x68, 0xdb, 0x8f, 0xc3, 0xc0,
    0x80, 0xda, 0xb8, 0xc2, 0x47, 0x0f, 0xff, 0xd9,
];

#[cfg(test)]
mod tests {
    use crate::{errors::BaseError, formats::jpeg};

    use super::*;

    // #[test]
    // fn test_parse_all_segments() {
    //     let mut data = io::Cursor::new(JPEG_DATA_1);
    //     match parse(&mut data) {
    //         Ok((jfif, exif)) => {
    //             // Validate JFIF
    //             let jfif = jfif.unwrap();
    //             assert_eq!(jfif.major, 1);
    //             assert_eq!(jfif.minor, 1);
    //             assert_eq!(jfif.density, DensityUnit::PixelsPerInch);
    //             assert_eq!(jfif.x_density, 72);
    //             assert_eq!(jfif.y_density, 72);
    //             assert_eq!(jfif.x_thumbnail, 0);
    //             assert_eq!(jfif.y_thumbnail, 0);

    //             // Exif
    //             let exif = exif.unwrap();
    //             assert_eq!(exif.is_big_endian(), true);
    //             //let exif = exif.unwrap();

    //             //assert_eq!(err_to_string(&err), "");
    //         }
    //         Err(e) => {
    //             assert_eq!(err_to_string(&e), "");
    //         }
    //     }
    // }

    #[test]
    fn test_parse_not_enough_data() {
        let mut data = io::Cursor::new(jpeg::marker::HEADER);
        let err = parse(&mut data).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
    }

    #[test]
    fn test_parse_header_invalid() {
        let mut header = io::Cursor::new([0xFF, 0x00]);
        assert_eq!(
            parse_header(&mut header).unwrap_err().to_string(),
            JpegError::header_invalid().to_string()
        );
    }

    #[test]
    fn test_parse_header_valid() {
        let mut header = io::Cursor::new(marker::HEADER);
        assert!(parse_header(&mut header).is_ok());
    }

    #[test]
    fn test_is_jpeg() {
        assert_eq!(is_jpeg(&marker::HEADER), true);
        assert_eq!(is_jpeg(&[0xFF, 0xF0]), false);
    }

    #[test]
    fn test_parse_segment_ask_for_more_data() {
        let err = parse_segment(&[]).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        assert_eq!(
            err.source_to_string(),
            "nom::Parsing requires 1 bytes/chars"
        );
    }

    #[test]
    fn test_parse_segment_exif_success() {
        // skip the JPEG header and JFIF segment
        let (_, segment) = parse_segment(&JPEG_TEST_DATA[20..]).unwrap();
        assert_eq!(segment.marker, marker::APP1);
        assert_eq!(segment.length, 860);
        assert_eq!(segment.data.unwrap().len(), 860);
    }

    // General segment
    // ---------------------------------------------------------------------------------------------

    #[test]
    fn test_parse_segment_marker_unknown() {
        let err = parse_segment(&[0xff, 0xe9]).unwrap_err();
        assert_eq!(
            err.to_string(),
            JpegError::segment_marker_unknown(&[0xff, 0xe9]).to_string()
        );
    }

    // JFIF segment
    // ---------------------------------------------------------------------------------------------

    #[test]
    fn test_parse_segment_jfif_success() {
        let (remain, segment) = parse_segment(&JPEG_TEST_DATA[2..20]).unwrap();
        assert_eq!(remain, &[]);
        assert_eq!(segment.marker, marker::APP0);
        assert_eq!(segment.data.unwrap(), &JPEG_TEST_DATA[6..20]);
    }

    #[test]
    fn test_parse_segment_data_not_enough_data() {
        let err = parse_segment_data(&JPEG_TEST_DATA[6..19], 14).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        assert_eq!(
            err.source_to_string(),
            "nom::Parsing requires 1 bytes/chars"
        );
    }

    #[test]
    fn test_parse_segment_data_valid() {
        let (remain, data) = parse_segment_data(&JPEG_TEST_DATA[6..20], 14).unwrap();
        assert_eq!(remain, &[]);
        assert_eq!(data, &JPEG_TEST_DATA[6..20]);
    }

    #[test]
    fn test_parse_length_ask_for_more_data() {
        let err = parse_segment_length(&[]).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        assert_eq!(
            err.source_to_string(),
            "nom::Parsing requires 2 bytes/chars"
        );
    }

    #[test]
    fn test_parse_segment_length_success() {
        let (remain, length) = parse_segment_length(&JPEG_TEST_DATA[4..6]).unwrap();
        assert_eq!(remain, &[]);
        assert_eq!(length, 14);
    }

    #[test]
    fn test_parse_segment_marker_success() {
        let (remain, marker) = parse_segment_marker(&JPEG_TEST_DATA[2..4]).unwrap();
        assert_eq!(remain, &[]);
        assert_eq!(marker, marker::APP0);
    }

    #[test]
    fn test_parse_segment_marker_not_enough_data() {
        let err = parse_segment_marker(&[0xFF]).unwrap_err();
        assert_eq!(err.to_string(), JpegError::not_enough_data().to_string());
        assert_eq!(
            err.source_to_string(),
            "nom::Parsing requires 1 bytes/chars"
        );
    }
}
