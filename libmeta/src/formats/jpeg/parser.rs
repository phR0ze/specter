use nom::{bytes::streaming as nom_bytes, error::Error as NomError, number::streaming as nom_nums};
use std::io::{self, prelude::*};

use crate::{
    errors::{DataError, JpegError, JpegErrorKind, MetaError},
    exif::{self, Exif},
    jfif::{self, Jfif},
    Kind, Meta,
};

use super::{
    marker,
    segment::{self, Segment},
};

/// Parse all meta data from the given JPEG source.
pub fn parse(mut reader: impl io::BufRead) -> Result<(Option<Jfif>, Option<Exif>), JpegError> {
    let mut jfif: Option<Jfif> = None;
    let mut exif: Option<Exif> = None;

    // Check the header to determine the media type
    parse_header(&mut reader)?;

    // TODO: change this to something larger in production
    let chunk_len = 10;

    // Loop over the source reading chunks of data and parse it into segments.
    // * Progressively load more data until all segments are parsed, but bail before
    //   reading the actual image data to avoid the unnecessary overhead.
    // * Break out into a multi-threaded approach later for performance, maybe?
    //   Highest performance option is to use a single thread to read data in chunks in
    //   a loop until all segments are parsed and image data is detected then abort.
    //   Meanwhile a worker thread is spawned to parse the segmments in parallel.
    let mut end_of_meta_data = false;
    let mut get_more_data = false;
    let mut buffer: Vec<u8> = Vec::with_capacity(4096); // rust std use 8k for most things
    let mut i = 0; // unacked start
    let mut j = 0; // unacked length
    loop {
        // Defensively discard unrecognized bytes up to next marker in an attempt to recover
        // from a corrupt JPEG source. Note: read_until will also discard the target value.
        // reader.read_until(JPEG_MARKER_PREFIX, &mut Vec::new());

        // Read the next chunk of data and store it in the buffer
        let mut buf: Vec<u8> = Vec::with_capacity(chunk_len);
        match reader.by_ref().take(chunk_len as u64).read_to_end(&mut buf) {
            Ok(0) => end_of_meta_data = true,
            Err(e) => return Err(JpegError::read_failed().with_io_source(e)),
            _ => (),
        }
        j += buf.len();
        buffer.extend_from_slice(&buf);
        get_more_data = false;

        // Loop parsing all segements switching on APP segment header
        loop {
            match segment::parse(&buffer[i..i + j]) {
                Ok((remain, segment)) => match segment.marker {
                    marker::APP0 => {
                        jfif = Some(jfif::parse(&segment.data.unwrap())?);
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::APP1 => {
                        // TODO: fix this
                        //exif = Some(exif::parse(&segment.data.unwrap())?);
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::DQT | marker::SOF | marker::DHT | marker::DRI => {
                        // Not sure what these are for yet
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::SOS => {
                        // last segment before image data so break out
                        end_of_meta_data = true;
                        break;
                    }
                    _ => {
                        return Err(JpegError::parse(": segment marker unknown").with_data(remain));
                    }
                },
                // Set the get_more_data flag and break the loop to read more data
                Err(JpegError {
                    kind: JpegErrorKind::Truncated,
                    ..
                }) => {
                    get_more_data = true;
                    break;
                }
                Err(e) => {
                    return Err(JpegError::new().wrap(e));
                }
            }
        }

        // End of metadata i.e. no more data in file or hit SOS
        if end_of_meta_data {
            if get_more_data {
                // If more data is needed must be a broken JPEG source
                return Err(JpegError::truncated());
            }
            break;
        }
    }

    Ok((jfif, exif))
}

/// Dump meta data segments from the given JPEG source for debugging purposes.
pub fn dump(mut reader: impl io::Read) -> Result<(), JpegError> {
    for segment in parse_segments(&mut reader)? {
        println!("{}", segment);
    }
    Ok(())
}

/// Parse out all the segments for the given JPEG source.
fn parse_segments(mut reader: impl io::Read) -> Result<Vec<Segment>, JpegError> {
    let mut segments = Vec::new();

    // Check the header to determine the media type
    parse_header(&mut reader)?;

    let chunk_len = 10;

    // Loop over the source reading chunks of data and parse it into segments.
    // * Progressively load more data until all segments are parsed, but bail before
    //   reading the actual image data to avoid the unnecessary overhead.
    // * Break out into a multi-threaded approach later for performance, maybe?
    //   Highest performance option is to use a single thread to read data in chunks in
    //   a loop until all segments are parsed and image data is detected then abort.
    //   Meanwhile a worker thread is spawned to parse the segmments in parallel.
    let mut end_of_meta_data = false;
    let mut get_more_data = false;
    let mut buffer: Vec<u8> = Vec::with_capacity(4096); // rust std use 8k for most things
    let mut i = 0; // unacked start
    let mut j = 0; // unacked length
    loop {
        // Defensively discard unrecognized bytes up to next marker in an attempt to recover
        // from a corrupt JPEG source. Note: read_until will also discard the target value.
        // reader.read_until(JPEG_MARKER_PREFIX, &mut Vec::new());

        // Read the next chunk of data and store it in the buffer
        let mut buf: Vec<u8> = Vec::with_capacity(chunk_len);
        match reader.by_ref().take(chunk_len as u64).read_to_end(&mut buf) {
            Ok(0) => end_of_meta_data = true,
            Err(e) => return Err(JpegError::read_failed().with_io_source(e)),
            _ => (),
        }
        j += buf.len();
        buffer.extend_from_slice(&buf);
        get_more_data = false;

        // Loop parsing all segements switching on APP segment header
        loop {
            match segment::parse(&buffer[i..i + j]) {
                Ok((remain, segment)) => match segment.marker {
                    marker::APP0 | marker::APP1 => {
                        segments.push(segment);
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::DQT | marker::SOF | marker::DHT | marker::DRI => {
                        i += j - remain.len();
                        j = remain.len();
                    }
                    marker::SOS => {
                        // last segment before image data so break out
                        end_of_meta_data = true;
                        break;
                    }
                    _ => {
                        return Err(JpegError::parse(": segment marker unknown").with_data(remain));
                    }
                },
                Err(JpegError {
                    kind: JpegErrorKind::Truncated,
                    ..
                }) => {
                    get_more_data = true;
                    break;
                }
                Err(e) => {
                    return Err(JpegError::new().wrap(e));
                }
            }
        }

        // End of metadata i.e. no more data in file or hit SOS
        if end_of_meta_data {
            if get_more_data {
                // If more data is still needed it must be truncated JPEG source
                return Err(JpegError::truncated());
            }
            break;
        }
    }

    Ok(segments)
}

// Determine if the given header is from a jpeg source
pub fn is_jpeg(header: &[u8]) -> bool {
    header.starts_with(&marker::HEADER)
}

// Parsee the JPEG header
fn parse_header(mut reader: impl io::Read) -> Result<bool, JpegError> {
    let mut header = [0u8; 2];
    reader
        .by_ref()
        .read_exact(&mut header)
        .map_err(|x| JpegError::read_failed().with_io_source(x))?;
    match is_jpeg(&header) {
        true => Ok(true),
        false => {
            return Err(JpegError::parse(": invalid header"));
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse() {
        let mut data = io::Cursor::new(JPEG_TEST_DATA);
        let segments = parse_segments(&mut data).unwrap();
        assert_eq!(segments.len(), 2);

        //     Ok((jfif, exif)) => {
        //         // Validate JFIF
        //         let jfif = jfif.unwrap();
        //         assert_eq!(jfif.major, 1);
        //         assert_eq!(jfif.minor, 1);
        //         assert_eq!(jfif.density, jfif::DensityUnit::PixelsPerInch);
        //         assert_eq!(jfif.x_density, 72);
        //         assert_eq!(jfif.y_density, 72);
        //         assert_eq!(jfif.x_dimension, 0);
        //         assert_eq!(jfif.y_dimension, 0);

        //         // Exif
        //         // let exif = exif.unwrap();
        //         // assert_eq!(exif.is_big_endian(), true);
        //         // //let exif = exif.unwrap();

        //         //assert_eq!(err_to_string(&err), "");
        //     }
        //     Err(e) => {
        //         assert_eq!(e.all_to_string(), "");
        //     }
        // }
    }

    #[test]
    fn test_parse_segments() {
        let mut data = io::Cursor::new(JPEG_TEST_DATA);
        let segments = parse_segments(&mut data).unwrap();
        assert_eq!(segments.len(), 2);
    }

    #[test]
    fn test_parse_not_enough_data() {
        let mut data = io::Cursor::new(marker::HEADER);
        let err = parse(&mut data).unwrap_err();
        assert_eq!(err.to_string(), JpegError::truncated().to_string());
    }

    #[test]
    fn test_parse_header_invalid() {
        let mut header = io::Cursor::new([0xFF, 0x00]);
        assert_eq!(
            parse_header(&mut header).unwrap_err().to_string(),
            JpegError::parse(": invalid header").to_string()
        );
    }

    #[test]
    fn test_parse_header_valid() {
        let mut header = io::Cursor::new(marker::HEADER);
        assert!(parse_header(&mut header).is_ok());
    }

    #[test]
    fn test_is_jpeg() {
        assert_eq!(is_jpeg(&marker::HEADER), true);
        assert_eq!(is_jpeg(&[0xFF, 0xF0]), false);
    }
}

#[cfg(test)]
pub(crate) const JPEG_TEST_DATA: [u8; 1260] = [
    /* 000-001 */ 0xff, 0xd8, // JPEG header
    /* 002-003 */ 0xff, 0xe0, // JFIF: marker
    /* 004-005 */ 0x00, 0x10, // JFIF: size
    /* 006-010 */ 0x4a, 0x46, 0x49, 0x46, 0x00, // JFIF: signature
    /* 011-019 */ 0x01, 0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, // JFIF: data
    /* 020-021 */ 0xff, 0xe1, // Exif: marker
    /* 022-023 */ 0x03, 0x5e, // Exif: size 862
    /* 024-029 */ 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, // Exif: signature
    //
    // TIFF header
    /* 030-031 */ 0x4d, 0x4d, // byte alignment
    /* 032-033 */ 0x00, 0x2a, // identifier
    /* 034-037 */ 0x00, 0x00, 0x00, 0x08, // IFD 0: offset
    //
    // IFD 0
    /* 038-039 */ 0x00, 0x06, // IFD 0: field count
    //
    /* 040-041 */ 0x01, 0x0e, // Field 0: Image description
    /* 042-043 */ 0x00, 0x02, // Field 0: format ASCII
    /* 044-047 */ 0x00, 0x00, 0x00, 0x0b, // Field 0: components
    /* 048-051 */ 0x00, 0x00, 0x00, 0x56, // Field 0: offset (86)
    //
    /* 052-053 */ 0x01, 0x1a, // Field 1: XResolution
    /* 054-055 */ 0x00, 0x05, // Field 1: format Unsigned Rational
    /* 056-059 */ 0x00, 0x00, 0x00, 0x01, // Field 1: components
    /* 060-063 */ 0x00, 0x00, 0x00, 0x62, // Field 1: offset (98)
    //
    /* 064-065 */ 0x01, 0x1b, // Field 2: YResolution
    /* 066-067 */ 0x00, 0x05, // Field 2: format
    /* 068-071 */ 0x00, 0x00, 0x00, 0x01, // Field 2: components
    /* 072-075 */ 0x00, 0x00, 0x00, 0x6a, // Field 2: offset (106)
    //
    /* 076-077 */ 0x01, 0x28, // Field 3: Resolution Unit
    /* 078-079 */ 0x00, 0x03, // Field 3: Unsigned short
    /* 080-083 */ 0x00, 0x00, 0x00, 0x01, // Field 3: components
    /* 084-087 */ 0x00, 0x02, 0x00, 0x00, // Field 3: data (512)
    //
    /* 088-089 */ 0x01, 0x32, // Field 4: Date Time
    /* 090-091 */ 0x00, 0x02, // Field 4: ASCII
    /* 092-095 */ 0x00, 0x00, 0x00, 0x14, // Field 4: components (20)
    /* 096-099 */ 0x00, 0x00, 0x00, 0x72, // Field 4: offset (114)
    //
    /* 100-101 */ 0x87, 0x69, // Field 5: ExifOffset
    /* 102-103 */ 0x00, 0x04, // Field 5: Unsigned Long
    /* 104-107 */ 0x00, 0x00, 0x00, 0x01, // Field 5: components
    /* 108-111 */ 0x00, 0x00, 0x00, 0x86, // Field 5: data (134)
    //
    /* 112-115 */ 0x00, 0x00, 0x00, 0xb0, // IFD 1: offset (176)
    //
    // Field 0: Data (11)
    /* 116-127 */ 0x54, 0x65, 0x73, 0x74, 0x20, 0x69, 0x6d,
    0x61, 0x67, 0x65, 0x00, 0x46, /* 128-139 */ 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x48, /* 000-151 */ 0x00, 0x00, 0x00, 0x01, 0x32, 0x30, 0x31,
    0x36, 0x3a, 0x30, 0x35, 0x3a, /* 000-163 */ 0x30, 0x34, 0x20, 0x30, 0x33, 0x3a, 0x30,
    0x32, 0x3a, 0x30, 0x31, 0x00, /* 000-175 */ 0x00, 0x03, 0x90, 0x00, 0x00, 0x07, 0x00,
    0x00, 0x00, 0x04, 0x30, 0x32, /* 000-187 */ 0x33, 0x30, 0xa0, 0x02, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x0f, /* 000-199 */ 0x00, 0x00, 0xa0, 0x03, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x07, /* 000-211 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x02, 0x01, 0x00, 0x04, /* 000-223 */ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xce, 0x02, 0x02, 0x00, 0x04, /* 000-235 */ 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02,
    0x88, 0x00, 0x00, 0x00, 0x00, //
    // JPEG Thumbnail
    /* 000-247 */ 0xff, 0xd8, // JPEG Header
    0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x01,
    0x00, 0x00, 0xff, 0xdb, 0x00, 0x43, 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07,
    0x07, 0x09, 0x09, 0x08, 0x0a, 0x0c, 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13, 0x0f,
    0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d, 0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c,
    0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29, 0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d,
    0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34, 0x32, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x09, 0x09, 0x09, 0x0c,
    0x0b, 0x0c, 0x18, 0x0d, 0x0d, 0x18, 0x32, 0x21, 0x1c, 0x21, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0xff, 0xc0, 0x00, 0x11,
    0x08, 0x00, 0x03, 0x00, 0x07, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff,
    0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
    0xff, 0xc4, 0x00, 0xb5, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04,
    0x04, 0x00, 0x00, 0x01, 0x7d, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41,
    0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1,
    0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19,
    0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64,
    0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84,
    0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2,
    0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9,
    0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
    0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3,
    0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff, 0xc4, 0x00, 0x1f, 0x01, 0x00, 0x03, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03,
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0xff, 0xc4, 0x00, 0xb5, 0x11, 0x00, 0x02, 0x01,
    0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02,
    0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32,
    0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72,
    0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29,
    0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73,
    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
    0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8,
    0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
    0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4,
    0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xff,
    0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3f, 0x00, 0xf4, 0x5d, 0x1e,
    0x15, 0xb9, 0x96, 0xd2, 0x09, 0x9a, 0x57, 0x89, 0x0c, 0x85, 0x53, 0xcd, 0x6c, 0x77, 0xf7, 0xe6,
    0x8a, 0x28, 0xa0, 0x0f, 0xff, 0xd9, //
    //
    // END OF EXIF
    //
    // Start of image data
    0xff, 0xdb, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04,
    0x03, 0x03, 0x04, 0x05, 0x08, 0x05, 0x05, 0x04, 0x04, 0x05, 0x0a, 0x07, 0x07, 0x06, 0x08, 0x0c,
    0x0a, 0x0c, 0x0c, 0x0b, 0x0a, 0x0b, 0x0b, 0x0d, 0x0e, 0x12, 0x10, 0x0d, 0x0e, 0x11, 0x0e, 0x0b,
    0x0b, 0x10, 0x16, 0x10, 0x11, 0x13, 0x14, 0x15, 0x15, 0x15, 0x0c, 0x0f, 0x17, 0x18, 0x16, 0x14,
    0x18, 0x12, 0x14, 0x15, 0x14, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05,
    0x09, 0x05, 0x05, 0x09, 0x14, 0x0d, 0x0b, 0x0d, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0xff, 0xc0, 0x00, 0x11, 0x08, 0x00,
    0x07, 0x00, 0x0f, 0x03, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00,
    0x15, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x06, 0x08, 0xff, 0xc4, 0x00, 0x1f, 0x10, 0x00, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x12, 0x13, 0x14, 0x15, 0x16, 0xff, 0xc4, 0x00, 0x14, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc4, 0x00, 0x14, 0x11,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xff, 0xdd, 0x00, 0x04, 0x00, 0x20, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x11,
    0x03, 0x11, 0x00, 0x3f, 0x00, 0xaa, 0x70, 0x7a, 0xcd, 0xe5, 0x83, 0xcc, 0xd9, 0xb3, 0x1a, 0xa6,
    0xb0, 0xb7, 0x9f, 0x61, 0x93, 0x4d, 0x7a, 0xb1, 0x2e, 0xe5, 0xfb, 0x91, 0xca, 0xb5, 0x5e, 0xb2,
    0x72, 0x39, 0x47, 0x43, 0xba, 0x50, 0x0e, 0x40, 0xa1, 0x20, 0xb4, 0x31, 0xe1, 0xf4, 0xbe, 0x36,
    0x5c, 0x54, 0x12, 0x39, 0x91, 0x41, 0x56, 0x3f, 0x85, 0x6d, 0x39, 0xfb, 0xb3, 0x0c, 0xba, 0xb5,
    0x97, 0xf2, 0xb0, 0xca, 0xaf, 0xd5, 0x94, 0xba, 0xb6, 0xe6, 0xca, 0x77, 0xce, 0xe3, 0xb6, 0x7c,
    0xd7, 0x38, 0xea, 0xfb, 0xca, 0x2e, 0xf7, 0x10, 0x91, 0xd0, 0x03, 0x68, 0xdb, 0x8f, 0xc3, 0xc0,
    0x80, 0xda, 0xb8, 0xc2, 0x47, 0x0f, 0xff, 0xd9,
];
